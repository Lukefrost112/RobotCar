{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"PS5 Controlled Smart Car","text":"<p>ESP32-based smart car controlled via a PS5 DualSense controller.</p>"},{"location":"#what-makes-this-build-different","title":"What makes this build different","text":"<ul> <li>Non-blocking firmware: no <code>delay()</code> anywhere; all timing uses <code>millis()</code>.</li> <li>Layered architecture: input \u2192 decision \u2192 execution \u2192 hardware outputs.</li> <li>Deterministic buzzer system: single-writer + priority-based state machine.</li> </ul>"},{"location":"#features","title":"Features","text":"<ul> <li>Differential drive mixing (throttle + steering)</li> <li>Deadzone filtering for stick/triggers</li> <li>RGB feedback (non-blocking blink patterns)</li> <li>Buzzer feedback:</li> <li>Connect/disconnect patterns</li> <li>Boost \u201cangry dog\u201d buzz</li> <li>Reverse warning buzz</li> <li>Horn</li> </ul>"},{"location":"#quick-start","title":"Quick Start","text":"<ul> <li>Controller connects via <code>ps5Controller</code> library</li> <li>Motor outputs are driven using ESP32 LEDC PWM channels</li> <li>Feedback subsystems are updated every loop (no blocking)</li> </ul>"},{"location":"architecture/","title":"Architecture","text":""},{"location":"architecture/#main-loop-philosophy","title":"Main Loop Philosophy","text":"<p>The firmware is structured so that all subsystems run concurrently without blocking.</p> <p>The loop performs a consistent pipeline:</p> <ol> <li>Read controller inputs</li> <li>Decide feedback states (buzzer/rgb)</li> <li>Execute feedback updates (millis-based)</li> <li>Compute drive command (throttle/steering mixing)</li> <li>Map drive command to motor driver PWM pins</li> <li>Write PWM to motors</li> </ol>"},{"location":"architecture/#why-no-delay","title":"Why no delay()","text":"<p>Using <code>delay()</code> would freeze: - controller responsiveness - smooth motor control - feedback timing accuracy</p> <p>Instead, timing is implemented with: - timestamps (<code>lastMs</code>) - intervals (<code>intervalMs</code>) - state variables (step counters / toggles)</p>"},{"location":"architecture/#subsystems","title":"Subsystems","text":""},{"location":"architecture/#input","title":"Input","text":"<p>Reads controller state into a <code>ControllerInput</code> struct (snapshot).</p>"},{"location":"architecture/#drive","title":"Drive","text":"<p>Converts input \u2192 <code>DriveCommand</code> \u2192 motor PWM outputs via: - deadzones - mixing - clamping - H-bridge mapping</p>"},{"location":"architecture/#feedback","title":"Feedback","text":"<p>Two independent non-blocking state machines: - RGB: blink patterns driven by toggles and counters - Buzzer: priority state machine that prevents multiple writers to BUZ pin</p>"},{"location":"hardware/","title":"Hardware Design","text":"<p>This project includes a full KiCad schematic for accurate electrical documentation.</p>"},{"location":"hardware/#power-architecture","title":"Power Architecture","text":"<p>The system uses: - 5V rail for buzzer and motor driver logic - 3.3V logic for ESP32</p> <p>All grounds are common.</p>"},{"location":"hardware/#buzzer-driver","title":"Buzzer Driver","text":"<p>The buzzer is driven using a BC547 NPN transistor:</p> <ul> <li>GPIO33 \u2192 1k\u03a9 resistor \u2192 Base</li> <li>Emitter \u2192 GND</li> <li>Collector \u2192 Buzzer negative</li> <li>Buzzer positive \u2192 5V</li> </ul> <p>This ensures: - Proper volume - No GPIO overcurrent - Stable system operation</p>"},{"location":"hardware/#motor-driver","title":"Motor Driver","text":"<p>The motor driver is controlled via 4 PWM channels.</p> <p>Differential drive logic is implemented in firmware.</p> <p></p> <p></p> <p></p>"},{"location":"wiring/","title":"Wiring and Power Design","text":""},{"location":"wiring/#system-overview","title":"System Overview","text":"<p>The smart car uses:</p> <ul> <li>ESP32 Dev Board</li> <li>H-Bridge Motor Driver</li> <li>Active Buzzer (5V via transistor)</li> <li>RGB LED</li> <li>Voltage Regulator</li> </ul>"},{"location":"wiring/#power-architecture","title":"Power Architecture","text":""},{"location":"wiring/#33v-rail","title":"3.3V Rail","text":"<p>Used for: - ESP32 logic - PS5 Bluetooth stack</p>"},{"location":"wiring/#5v-rail","title":"5V Rail","text":"<p>Used for: - Active buzzer (through transistor)</p> <p>Why?</p> <p>The buzzer volume was too low at 3.3V. Driving it from 5V via a transistor ensures: - Loud output - No ESP32 pin overload - Stable operation</p>"},{"location":"wiring/#buzzer-wiring","title":"Buzzer Wiring","text":"<ul> <li>ESP32 pin \u2192 Base of BC547 (via resistor)</li> <li>Collector \u2192 Buzzer negative</li> <li>Buzzer positive \u2192 5V</li> <li>Emitter \u2192 GND</li> </ul> <p>This allows: - ESP32 to control buzzer safely - Buzzer to run at full 5V - No resets due to power noise</p>"},{"location":"wiring/#motor-driver-pins","title":"Motor Driver Pins","text":"ESP32 Pin Function 5 M1A 18 M1B 19 M2A 21 M2B <p>PWM frequency: 10 kHz Resolution: 8-bit (0\u2013255)</p>"},{"location":"wiring/#ground-considerations","title":"Ground Considerations","text":"<p>All grounds must be common between: - ESP32 - Motor driver - Voltage regulator - Buzzer transistor</p> <p>Incorrect grounding may cause: - Random resets - Unstable Bluetooth - Buzzer glitches</p>"},{"location":"firmware/buzzer/","title":"Buzzer System","text":""},{"location":"firmware/buzzer/#goals","title":"Goals","text":"<ul> <li>Non-blocking sound (no delay)</li> <li>Clear priorities between sounds</li> <li>Predictable transitions between modes</li> <li>Single-writer control of <code>BUZ</code></li> </ul>"},{"location":"firmware/buzzer/#two-categories-of-sound","title":"Two categories of sound","text":""},{"location":"firmware/buzzer/#1-finite-patterns-event-based","title":"1) Finite patterns (event-based)","text":"<p>Examples: - controller connected - controller disconnected</p> <p>These have a clear start and end.</p> <p>Implementation: - <code>startBeepPattern()</code> prepares a short pattern (ON/OFF durations) - <code>updateBuzzer()</code> advances the pattern with <code>millis()</code></p> <p>A pattern is considered \u201cplaying\u201d when: - <code>feedback.buzzerActive == true</code></p>"},{"location":"firmware/buzzer/#2-continuous-modes-condition-based","title":"2) Continuous modes (condition-based)","text":"<p>Examples: - BOOST is held \u2192 fast buzz - reversing \u2192 slow buzz - horn is held \u2192 constant ON</p> <p>Implementation: - <code>updateBuzzerSystem()</code> runs the current mode and toggles based on timers.</p>"},{"location":"firmware/buzzer/#buzzerstate-modes","title":"BuzzerState Modes","text":"<ul> <li><code>PATTERN</code>: plays finite connect/disconnect pattern</li> <li><code>BOOST</code>: fast square-wave toggle while boost held</li> <li><code>REVERSE</code>: slow square-wave toggle while reversing</li> <li><code>HORN</code>: constant HIGH while honk held</li> <li><code>STANDBY</code>: forced LOW</li> </ul>"},{"location":"firmware/buzzer/#priority-single-active-mode","title":"Priority (single active mode)","text":"<p>The firmware selects one mode each loop. A typical priority order is:</p> <p>PATTERN &gt; HORN &gt; BOOST &gt; REVERSE &gt; STANDBY</p> <p>(You can swap BOOST/HORN if desired. The key is consistency.)</p>"},{"location":"firmware/buzzer/#why-state-transitions-reset-timers","title":"Why state transitions reset timers","text":"<p>When switching modes, the system resets: - the mode timer - and often forces BUZ LOW</p> <p>This ensures: - no inherited timing from previous mode - no mid-cycle half-beeps - immediate stop when leaving a mode (especially BOOST)</p>"},{"location":"firmware/functions/","title":"Function Reference","text":"<p>This page describes what each major function does and why it exists.</p>"},{"location":"firmware/functions/#input","title":"Input","text":""},{"location":"firmware/functions/#readcontrollercontrollerinput-c","title":"readController(ControllerInput &amp;c)","text":"<p>Reads controller state and writes it into the <code>ControllerInput</code> struct. This isolates hardware reads from the rest of the logic.</p>"},{"location":"firmware/functions/#drive","title":"Drive","text":""},{"location":"firmware/functions/#applydeadzoneint-value-int-deadzone","title":"applyDeadzone(int value, int deadzone)","text":"<p>Zeroes small values to remove controller noise.</p>"},{"location":"firmware/functions/#computedrivecommandconst-controllerinput-c-drivecommand-d","title":"computeDriveCommand(const ControllerInput c, DriveCommand &amp;d)","text":"<p>Converts raw inputs into: - throttle (r2 - l2) - steering (lx) - mixed left/right outputs</p> <p>Also clamps left/right outputs to safe range.</p>"},{"location":"firmware/functions/#mapmotorint-cmd-stopmode-stop","title":"mapMotor(int cmd, StopMode stop)","text":"<p>Converts a signed motor command into two PWM channel outputs to control direction using an H-bridge.</p>"},{"location":"firmware/functions/#writemotoroutputsconst-motorout-left-const-motorout-right","title":"writeMotorOutputs(const MotorOut left, const MotorOut right)","text":"<p>Writes PWM values using ESP32 LEDC channels.</p>"},{"location":"firmware/functions/#feedback-rgb","title":"Feedback (RGB)","text":""},{"location":"firmware/functions/#setrgbint-r-int-g-int-b","title":"setRGB(int r, int g, int b)","text":"<p>Sets the RGB pins HIGH/LOW.</p>"},{"location":"firmware/functions/#startrgbblinkint-r-int-g-int-b-int-intervalms-int-blinkcount","title":"startRGBBlink(int r, int g, int b, int intervalMs, int blinkCount)","text":"<p>Prepares a non-blocking blink pattern.</p>"},{"location":"firmware/functions/#updatergbunsigned-long-nowms","title":"updateRGB(unsigned long nowMs)","text":"<p>Advances the blink pattern based on <code>millis()</code> timing.</p>"},{"location":"firmware/functions/#feedback-buzzer","title":"Feedback (Buzzer)","text":""},{"location":"firmware/functions/#startbeeppatternint-beepcount","title":"startBeepPattern(int beepCount)","text":"<p>Prepares a finite beep pattern (connect/disconnect).</p>"},{"location":"firmware/functions/#updatebuzzerunsigned-long-nowms","title":"updateBuzzer(unsigned long nowMs)","text":"<p>Plays the finite beep pattern without blocking.</p>"},{"location":"firmware/functions/#decidebuzzerstate","title":"decideBuzzerState(...)","text":"<p>Selects which buzzer mode should be active this loop based on current conditions (pattern playing, buttons, reverse, etc.).</p>"},{"location":"firmware/functions/#updatebuzzersystembuzzerstate-state","title":"updateBuzzerSystem(BuzzerState state)","text":"<p>The only function allowed to directly drive the BUZ pin. Executes the current buzzer mode.</p>"},{"location":"firmware/overview/","title":"Firmware Overview","text":""},{"location":"firmware/overview/#key-data-structures","title":"Key Data Structures","text":""},{"location":"firmware/overview/#controllerinput","title":"ControllerInput","text":"<p>A snapshot of raw controller state: - connection status - steering axis (<code>lx</code>) - triggers (<code>r2</code>, <code>l2</code>) - action buttons (<code>honk</code>, <code>boost</code>)</p>"},{"location":"firmware/overview/#drivecommand","title":"DriveCommand","text":"<p>Processed driving intent: - <code>throttle</code>: forward/back value from triggers - <code>steering</code>: steering value from stick - <code>left</code>, <code>right</code>: mixed outputs for differential drive</p>"},{"location":"firmware/overview/#feedbackstate","title":"feedbackState","text":"<p>Tracks non-blocking timing + state for: - buzzer pattern playback - RGB blink playback</p>"},{"location":"firmware/overview/#design-rule-important","title":"Design Rule (important)","text":"<p>Only one function should write to the buzzer pin.</p> <p>This prevents \u201ctick\u201d bugs caused by multiple parts of the code fighting over <code>BUZ</code>.</p>"},{"location":"firmware/rgb/","title":"RGB System","text":""},{"location":"firmware/rgb/#goal","title":"Goal","text":"<p>Provide clear visual feedback without blocking motor control.</p>"},{"location":"firmware/rgb/#how-it-works","title":"How it works","text":"<p>The RGB subsystem uses: - <code>rgbActive</code>: whether a blink pattern is running - <code>rgbIntervalMs</code>: time between toggles - <code>rgbBlinksLeft</code>: number of remaining ON pulses - <code>rgbOn</code>: current on/off state</p>"},{"location":"firmware/rgb/#startrgbblink","title":"startRGBBlink()","text":"<p>Prepares a pattern: - saves target color - sets blink count and interval - resets timing state</p>"},{"location":"firmware/rgb/#updatergb","title":"updateRGB()","text":"<p>Runs every loop: - checks if interval elapsed - toggles LED on/off - decrements blink count only after completing an ON\u2192OFF cycle</p>"}]}